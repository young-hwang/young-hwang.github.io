이진수는 컴퓨터의 언어라고 불릴 만큼, 디지털 시스템의 가장 기본적인 숫자 체계입니다. 하지만 이진수는 단순히 0과 1의 조합을 넘어서, **양수와 음수**를 표현하는 방법에 있어서도 중요한 역할을 합니다. 특히 **음수**를 표현하기 위한 다양한 방식이 존재하며, 이를 이해하는 것은 컴퓨터 시스템의 동작 원리를 깊이 있게 이해하는 데 필수적 입니다.

이번 글에서는 **이진수의 기본 개념**과 함께, 컴퓨터가 어떻게 **음수를 표현**하고 처리 하는지에 대해 알아보겠습니다.  **2의 보수**(Two’s Complement)와 같은 중요한 개념들을 살펴보며, 음수 표현 방식의 원리와 그 이유를 탐구해 보겠습니다. 

# 1. 2진수의 수 표현법

알다시피 컴퓨터는 사람과 같이 10진수 숫자를 이해하고 숫자를 메모리 저장하거나 불러오는 것이 아닙니다.

단지 0과 1이라는 2가지 값을 이용하여 표현을 하게 되며 이처럼 2가지 표현을 할 수 있는 것을 1비트(bit)라고 합니다.

간단히 4비트를 활용하여 수를 표현한다면 아래와 같이 표현이 가능할 것입니다.

| $0000_{(2)} = 0_{(10)}$ |
| ----------------------- |
| $0001_{(2)} = 1_{(10)}$ |
| $0010_{(2)} = 2_{(10)}$ |
| …                       |
| $1000_{(2)} = 8_{(10)}$ |

여기서 10진수를 2진수로 표현하는데 아무런 문제가 없어보입니다. 하지만 잠시 생각해보면 우리가 사용하는 수의 체계는 양수(양의 정수)만 존재하는 것은 아닙니다. 음의 정수도 포함이 되어야 한다는 것입니다.

그렇다면 어떻게 음수를 표현해야 할까요?

# 2. 부호 절대값(Sign-Magnitude)

간단히 적용할 수 있는 방법으로는 최상위 비트(가장 왼쪽의 비트)를 활용하는 방법입니다. Java에서 int는 4byte(32bit) 자료형을 사용하므로 이를 기준으로 살펴보겠습니다.

예를 들어 숫자 7을 표현한다고 가정해 보겠습니다. 그렇다면 2진수 값을 아래와 같을 것입니다.

$$
0000\ 0000\ 0000\ 0111_{(2)} = 7_{(10)} 
$$

만약 ‘-7’을 표현한다면 어떻게 할까요?

최상위 비트(가장 왼쪽의 비트)를 `0`일 때는 양수, `1`일 때는 음수로 약속을 하고 이용하는 것입니다. 즉 $7_{(10)}$에서 최상위 비트의 값을 바꿔주는 것입니다.

$$
1000\ 0000\ 0000\ 0111_{(2)} = -7_{(10)} 
$$

이렇게 최상위 비트를 이용하는 방식을 이용하여 음수를 표현할 수 있습니다. 이 최상위 비트를 Most Significant Bit(MSB)라고도 합니다.최상위 비트를 부호 절대값으로 사용하는 방식은 매우 직관적이나 컴퓨터 입장에서는 여러모로 어려운점들이 있습니다.

다신 간단히 4bit로 음수와 양수를 표현한다고 해보겠습니다.

| 양수                       | 음수                       |
| ------------------------ | ------------------------ |
| $0000_{(2)} = +0_{(10)}$ | $1000_{(2)} = -0_{(10)}$ |
| $0001_{(2)} = 1_{(10)}$  | $1001_{(2)} = -1_{(10)}$ |
| $0010_{(2)} = 2_{(10)}$  | $1010_{(2)} = -2_{(10)}$ |
| $0011_{(2)} = 3_{(10)}$  | $1011_{(2)} = -3_{(10)}$ |
| $0100_{(2)} = 4_{(10)}$  | $1100_{(2)} = -4_{(10)}$ |
| $0101_{(2)} = 5_{(10)}$  | $1101_{(2)} = -5_{(10)}$ |

이렇게 구성된 2진수에 대하여 덧셈을 한다면 어떨까요? 예로 17과 25를 더한다면 아래와 같을 것입니다.

$$
\begin{array}{r}
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
+\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
\hline\ 
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0010\ 1010
\end{array}

\begin{array}{r}
17 \\ +\ 25 \\
\hline
42
\end{array}
$$

크게 문제 없이 잘 계산됩니다. 그렇다면 최상위 비트를 이용한 음수를 더하는 것은 어떨까요?

두 수의 덧셈에서 음수가 계산되는 경우는 3가지가 있을 것입니다.

1. 첫번째 수만 음수인 경우
2. 두번째 수만 음수인 경우
3. 두 수 모두 음수인 경우

먼저 두 수 모두 음수 인 경우 부터 살펴 본 후 나머지 2가지 경우를 살펴 보겠습니다.

## 2.1 두 수 모두 음수인 경우

17과 25가 모두 음수 일 때, 즉 -17과 -25일때의 덧셈 결과는 -17 -25 = -42 가 될 것입니다.
좀 더 편하게 -(17 + 25) = -42라고 볼 수 있을 겁니다.
이를 2진수로 표현하면 아래와 같을 것 입니다.

$$
\begin{array}{r}
1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
+\ 1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
\hline\ 
1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0010\ 1010
\end{array}

\begin{array}{r}
-17 \\ +\ -25 \\
\hline
-42
\end{array}
$$

최상위 비트는 부호를 의미하며 두 수의 부호가 모두 음수로 같으므로 그대로 사용하게 됩니다. 나머지 비트들은 덧셈을 합니다. 문제 없이 음수 합이 계산 되었습니다.

## 2.2 첫번째 수만 음수인 경우

이번엔 첫번째 수만 음수인 경우를 살펴 보겠습니다. -17과 25의 덧셈은 우리는 쉽게 8이라는 것을 알 수 있습니다.  첫번째 수 17은 두번째 수 25보다 절대값이 작습니다. 
이를 2진수로 계산한다면 어떨까요?

$$
\begin{array}{r}
1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
+\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
\hline\ 
?000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0010\ 1010\\
\end{array}

\begin{array}{r}
-17 \\ +\ 25 \\
\hline
8
\end{array}
$$

먼저 두 이진수를 더하면 42가 되어 버립니다. MSB에 +, - 무엇을 붙여 주더라도 올바른 답이 될 수 없습니다.

그렇다고 25를 빼면 어떻게 될까요?

$$
\begin{array}{r}
1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
+\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
\hline\ 
?111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1000\\
\end{array}

\begin{array}{r}
-17 \\ +\ 25 \\
\hline
8
\end{array}
$$

MSB를 제외한  나머지 비트에서 25를 빼주어야 하는데 이 또한 올바른 계산이 될 수 없습니다.

그렇다면 해결 방법은 없는 것 일까요?

가장 쉽게 해결 할 수 있는 방법은 바로 '절대값'이 큰 수가 첫번째 수가 되도록 하는 것입니다.
즉 17과 25중 절대값이 큰 25가 첫번째 수가 되는 것입니다. 즉 -17+25에서 25-17이 되도록 하는 것입니다.

$$
\begin{array}{r}
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
-\ 1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
\hline\ 
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 1000\\
\end{array}

\begin{array}{r}
25 \\ -\ 17 \\
\hline
8
\end{array}
$$

## 2.3 두번째 수만 음수인 경우

그렇다면 이번엔 -25라면 어떻게 계산 될까요? 
이전과 마찬가지로 큰값에서 작은 값을 뺀다면 17 - 25 = -(25 - 17) 과 같을 것입니다.
따라서 25 - 17 값에 음수를 취해 주면 됩니다.

$$
\begin{array}{r}
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
-\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
\hline\ 
1000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 1000\\
\end{array}

\begin{array}{r}
25 \\ -\ 17 \\
\hline
8
\end{array}
$$

이 방식이 사람한테는 쉬운 것처럼 보이나 막상 회로로 구성하려면 모든 경우의 수를 고려해야 하기에 쉬운 방식은 아닙니다.
특히 음수가 끼어 있을 경우 각 상황마다 MSB를 어떻게 처리해야 될지, 어떤 수가 첫번째 수가 되어야 될지 고려해야 할 것들이 많습니다.

## 2.4 장단점

이러한 방식의 장단점은 무엇일까요? 
일단 MSB만 고려해주면 되기 때문에 사람이 이해하기 쉽다는 것이 장점이 될 것입니다.
그렇다면 단점은 어떠한 것이 있을까요?

1. +0 과 -0이 함께 존재하기에 둘다 0으로 인식하도록 만들어야 합니다.
2. 연산에서 고려해야 될 것들이 많아져 회로가 복잡해집니다.(MSB 값과 절대값 비교 계산 필요)

# 3. 보수

먼저 보수라는 의미를 아시나요?

> 보수란 사전적 의미로 어떤 수와 더하여 일정한 수가 되도록 하는 수. 주어진 기수 체계에서 특정 자릿수의  최대값에 대한 차이를 나타내는 수라고 합니다.

예를 들어 십진 보수 체계를 사용한다면 1의 10의 보수는 1에 9를 더해 10이 되므로 9가 보수가 되게 됩니다. 17의 10의 보수라고 한다면 17에서 100이 되기위해 필요한 83이 됩니다.

즉 n진법에서 n의 보수라고 하면 n의 각 자리수 최대값이 되도록 만드는 수라고 할 수 있습니다.

| 자릿**수** | 최대값  |    사용 예     |
| :-----: | :--: | :---------: |
|   1자리   |  10  |  9의 보수 + 1  |
|   2자리   | 100  | 99의 보수 + 1  |
|   3자리   | 1000 | 999의 보수 + 1 |

십진 보수 체계에서는 10의 보수를 살펴 보았습니다. 
여기서 우리는 보수에 대하여 좀더 알아보기 위해 9의 보수를 한번더 보도록하겠습니다.
9의 보수는 10의 배수와 마찬가지로 각 자리수 최대값 9가 되도록 만드는 수 입니다.

| 자릿**수** |  값  |    사용 예     |
| :-----: | :-: | :---------: |
|   1자리   |  9  |  8의 보수 + 1  |
|   2자리   | 99  | 98의 보수 + 1  |
|   3자리   | 999 | 998의 보수 + 1 |

10의 보수와 9의 보수에는 중요한 점이 있는데요. 바로 10의 보수 - 1이 9의 보수가 된다는 것입니다.

17에 대한 10의 보수는 83 이였습니다. 
$$
(100 - 17) = 83
$$
그렇다면 9의 보수는 무엇일까요?

$$
(99 - 17) = (100 - 17) - 1 = 82
$$
82로 10의 보수에 -1을 한것과 같습니다.
찬찬히 다시 생각해 보면 10의 보수를 구하여 -1을 하면 9의 보수가 된다는 것입니다.
반대로 9의 보수를 구해 1을 더한다면 10의 보수가 될 것입니다.

- 10의 보수 -> 9의 보수 구하기
$$
(1000 - 111) = 889 (10의 보수)
$$
$$
(1000 - 111) - 1 = 888 (9의 보수)
$$
- 9의 보수 -> 10의 보수 구하기
$$
(999 - 111)  = 888 (9의 보수)
$$
$$
(999 - 111) + 1 = 889 (10의 보수)
$$
두번째 방법을 보면 결국 n 진법의 n - 1 보수는 음수가 되지 않는 선에서 n - 1로 채운 수가 됩니다.
이러한 n-1의 보수를 구하는것이 왜 필요할까?

만약 8진법에서 8의 보수와 7의 보수를 구해보겠습니다.
8진법에서 123(8)은 10진법의 35 입니다. 이를 8의 보수와 7의 보수를 모두 구해보면 아래와 같을 것입니다.

- 8의 보수 -> 7의 보수
$$ 
(1000(8) - 123(8)) = 655(8) (8의 보수)
$$
$$
655(8) - 1(8) = 654(8)(7의 보수)
$$
- 7의 보수 -> 8의 보수
$$
(777(8) - 123(8)) = 654(7의 보수)
$$
$$
654(8) + 1(8)) = 655(8의 보수)
$$
두가지 방법으로 보수를 구했을 때 무엇이 더 쉽게 느껴지나요?

지금까지 보수의 원리에 대해 살펴 보았습니다. 그렇다면 왜 보수를 사용하여야 할까요?

# 4. 보수가 왜 필요한가?

앞서 부호와 절대값을 고려한 음수 덧셈(뺄셈)의 경우 고려해야 할 점이 많았습니다.
보수를 이용하여 뺄셈을 할 수 있는데, 이는 컴퓨터 입장에서 좀 더 쉽고 일관되게 계산 할 수 있습니다.

## 4.1 10의 보수 활용

한마디로 음수, 양수 상관 없이 일관되게 덧셈만을 이용하여 결과를 도출하게 됩니다.
앞서 보았던 -17 + 25를 다시 예로 살펴 보겠습니다.

$$
\begin{align}
& -17 + 25 \\
&= (100 - 17) + 25 - 100 \\
&= 83 + 25 - 100 \\
&= 108 - 100 \\
&= 8
\end{align}
$$

수학적으로 보수를 구해 계산한다면 위와 같을 것입니다. 
이를 조금 응용하여 '보수' 만 구해주는 방식으로 변형할 수 있습니다.

보수를 구하기 위해 100이 더해진 만큼 100을 빼주었는데 그냥 보수를 구하기만 하고 다시 빼지는 않는 것입니다.

$$
\begin{align}
& -17 + 25 \\
&= (100 - 17) + 25  \\
&= 83 + 25 \\
&= 108 \\
\end{align}
$$
여기서 가장 왼쪽 값 1은 올림이 발생한 수이므로 이를 버립니다.
최상위 비트(MSB)에서 '자리  올림'이 되었다는 의미로 '캐리 발생'이라고도 합니다.
정리하면 '108'에서 1이라는 수를 버린 '08' 즉 '8'이 됩니다.

**여기서 중요한 점은 캐리가 발생할 경우 '양수'라는 의미이고, 캐리가 발생하지 않을 경우 '음수'라는 의미 입니다.**

이번에는 17 - 25를 하면 어떨까요?

$$
\begin{align}
& 17 - 25 \\
&= 17 + (100 - 25)  \\
&= 17 + 75 \\
&= 92 (올림이 발생하지 않았으므로 보수를 구함) \\
&= 100 - 92 \\
&= 8 (올림이 발생하지 않았으므로 음수) \\
&= -8
\end{align}
$$

올림이 발생하지 않았으므로 음수라의 의미이며 보수를 취해 -8이라는 값을 얻을 수 있습니다.

다시 한번 정리해보자면 음수를 더할 시 보수를 더해서 올림이 발생하면 결과는 양수이고 올림 수는 버립니다.
올림이 발생하지 않은 수는 음수이고 계산 결과의 보수 값이 최종 값이 됩니다.


## 4.2 9의 보수 활용

그렇다면 이번에 9의 보수를 이용해서 계산하면 어떨까요?
-17 + 25를 먼저 9의 보수를 이용하여 계산해 보겠습니다.
앞서 말했는 9의 보수는 10의 보수 - 1 입니다.

$$
\begin{align}
& -17 + 25 \\
&= (99 - 17) + 25 \\
&= 82 + 25 \\
&= 107 (올림이 발생하였으므로 양수) \\
&= 7 + 1 (올림이 발생하였으므로 결과값에 1을 더함) \\
&= 8 \\
\end{align}
$$

17 - 25를 계산하면 어떨까요?

$$
\begin{align}
& 17 - 25 \\
&= 17 + (99 - 25) \\
&= 17 + 74 \\
&= 91 (올림이 발생하지 않았으므로 음수) \\
&= 99 - 91 (올림이 발생하지않았으므로 보수 구함) \\
&= 8 \\
&= -8 \\
\end{align}
$$

이렇게 보수를 활용하면 뺄셈을 계산할 때 용이하게 할 수 있습니다.

# 5. 1의 보수

지금까지 N 진법에서 보수를 구하는 방법과 왜 필요한지에 대해서 확인해 보았습니다.
우리가 보수를 구할 시 N의 보수를 구하는 것 보다 N-1의 보수를 구하는 것이 더 편하다는 것을 인자하게 되었을 것입니다.

컴퓨터에서 다루게 되는 비트는 0, 1을 가지는 2진수 입니다. 

예를 들어 2진수 1byte = 8bit 를 다룬다고 해보겠습니다. 
그렇다면 MSB 1자리와 7자리의 값을 가지게 될 것입니다.

0000 0011(2) = 3(10) 의 2의 보수를 구한다면 `1 0000 0000(2) - 0000 0011(2) = 1111 1101(2)` 가 될 것입니다.

이는 비트가 한정 되어있는 경우 보수를 구하는 과정에서 +1 비트 한칸이 더 필요하고, 거기에 내림을 해야하기 때문에 실질적으로 9bit가 필요하게 됩니다.

이번에는 1의 보수 통해 보수를 구해보겠습니다. `1111 1111(2) - 0000 0011(2) = 1111 1100(1의 보수), 1111 1100 + 1 = 1111 1101(2의 보수)`으로 좀 더 편리하게 보수를 구할 수 있습니다. 
즉 3을 뺄셈할 때(= -3) 위의 수를 이용할 수 있다는 것입니다.
이를 이용하여 위해서 설명한 10진수의 9의 보수를 이용한 뺄셈 처럼 같은 원리를 적용하여 계산할 수 있게 됩니다.


1의 보수를 살펴 보시면 아시겠지만 1의 보수 방식에서 **음수는 양수의 비트를 반전 시킨 값**입니다.

3을 이진수로 나타내면 0000 0011 이지만 비트를 반전(NOT) 연산을 하면 1111 1100이고 이것이 1의 보수에서의 -3 비트가 되는 것입니다.

**1의 보수에서 양수, 음수**

| 10 진수(양수) |  2진수(양수)  | 10진수(음수) |  2진수(음수)  |
| :-------: | :-------: | :------: | :-------: |
|    +0     | 0000 0000 |    -0    | 1111 1111 |
|     1     | 0000 0001 |    -1    | 1111 1110 |
|     2     | 0000 0010 |    -2    | 1111 1101 |
|     3     | 0000 0011 |    -3    | 1111 1100 |
|    ...    |    ...    |   ...    |    ...    |
|    127    | 0111 1111 |   -127   | 1000 0000 |

이렇게 1의 보수를 이용하여 음수를 만들경우 비트만 반전하면 된다는 장점을 얻었습니다.
1의 보수 방식을 통해 부호 절대값에서 문제가 되어었던 부호와 절대값을 따로 계산할 필요가 없어지고 뺄셈 대신 음수를 더하기만 하면 된다는 장점이 생겼습니다.

하지만 1의 보수도 단점이 존재합니다. 10의 보수와 9의 보수에서도 설명했지만 N-1의 보수는 캐리(올림)이 발생하면 +1을 더해주어야 한다는 것입니다.

다시 17과 25를 가지고 여러 계산을 수행해 보겠습니다.

**17 + 25**

$$
\begin{array}{r}
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
+\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
\hline\ 
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0010\ 1010
\end{array}

\begin{array}{r}
17 \\ +\ 25 \\
\hline
42
\end{array}
$$
양수 끼리의 합은 문제 없이 잘 수행 됩니다.

**-17 + 25**

$$
\begin{array}{r}
1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1110\ 1110\\
+\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
\hline\ 
1\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0111\\
\hline
\text{캐리발생} \\
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 1000\\
\end{array}
\begin{array}{r}
-17 \\ 
+\ 25 \\
\hline
7 \\
\hline
\text{} \\
\ (7 + 1)
\end{array}
$$

-17에 25를 더해주면 MSB 자리를 넘어 올림이 발생합니다. 그럴 때는 계산 값에 +1을 해주면 됩니다.

**-17 -25**

$$
\begin{array}{r}
1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1110\ 1110\\
+\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1110\ 0110\\
\hline\ 
1\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1101\ 0100\\
\hline
\text{캐리발생} \\
1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1100\ 0101\\
\end{array}
\begin{array}{r}
-17 \\ 
\ -25 \\
\hline
-43 \\
\hline
\text{} \\
\ (-43 + 1)
\end{array}
$$

캐리가 발생하여 +1을 해주면 올바른 값이 됩니다.

**17 - 25**

$$
\begin{array}{r}
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
+\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1110\ 0110\\
\hline\ 
1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 0111\\
\end{array}
\begin{array}{r}
17 \\ 
\ -25 \\
\hline
-8 \\
\end{array}
$$

캐리가 발생하지 않았습니다.
이렇게 비트를 더해 주더라도 MSB가 1일 경우 음수, 0일 경우 양수는 유지하며 캐리가 발생한 경우 +1을 해주면 되기에 편리해 보입니다.

하지만 여전히 문제점이 남아 있습니다.

캐리가 발생했을 때 처리를 해야 함과 +0과 -0이 존재한다는 것입니다.

따라서 1의 보수 방식의 장단점을 정리하면 아래와 같습니다.

- 장점
	- 비트만 반전 시키면 음수를 구할 수 있다.
	- MSB의 성질이 유지 된다.
	- 덧셈 만으로 뺄셈을 구현 할 수 있고 비교적 회로도 단순하다.
- 단점
	- 캐리가 발생하는 경우를 처리해야 한다.
	- -0과 +0 모두를 인지할 수 있도록 처리해야 한다.
# 6. 2의 보수

1의 보수를 사용하면 캐리가 발생하는 경우 +1을 해야 하고, -0과 +0이 둘다 존재한다는 것을 고려해야 한다.

그러면 이를 해결할 방법은 없는 걸까요?

간단히 -0을 없애면 될것입니다.
즉, 음수 영역에서 1의 보수에 대응되는 수를 -1 부터 대응 시키는 것입니다.

| 10 진수(양수) |  2진수(양수)  | 10진수(음수) |  1진수(음수)  |  2진수(음수)  |
| :-------: | :-------: | :------: | :-------: | :-------: |
|    +0     | 0000 0000 |    -0    | 1111 1111 |           |
|     1     | 0000 0001 |    -1    | 1111 1110 | 1111 1111 |
|     2     | 0000 0010 |    -2    | 1111 1101 | 1111 1110 |
|     3     | 0000 0011 |    -3    | 1111 1100 | 1111 1101 |
|    ...    |    ...    |   ...    |    ...    |    ...    |
|    127    | 0111 1111 |   -127   | 1000 0000 | 1000 0001 |
|           |           |   -128   |           | 1000 0000 |
음수 영역에서 1의 보수에 대응되는 수를 -1 부터 대응 시키는 것은 다시 말하면 어떤 수 a에 대한 1의 보수 + 1 이라는 것으로 즉 2의 보수를 구한 것과 같은 말입니다.

1에 대해 -1을 표현하기 위해 1의 보수를 이용하면 비트를 반전시키면 된다고 했었죠?

2-3 을 연산하려고 할 때, 뺄셈 대신 음수를 더하는 방식을 사용하기 위해 보수를 이용하는데, -3을 하기위한 3에 대한 1의 보수는 0000 0011(2) 비트를 반전시킨 1111 1100(2) 였죠.
하지만 위 2의 보수를 이용한 음수를 표현하는 표에서 1111 1100(2) 는 -3이 아닌 -4입니다. 
만약 -3을 표현하고자 한다면 -4에 +1을 해주어야 겠죠.

**"어떤 수를 부호를 바꾸고자 한다면 비트를 반전시킨 뒤 1을 더하면 된다"**

그러면 일단은 -0의 문제가 해결 된 것 같군요. 
문제는 캐리 발생 여부에 따라 추가 작업이 필요한 것이 해결이 되었느냐겠죠? 신기하게도 해결이 됩니다.

다시 17과 25을 갖고와서 4가지 경우를 다시 해보도록 하겠습니다.

**17 + 25**

$$
\begin{array}{r}
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
+\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
\hline\ 
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0010\ 1010
\end{array}

\begin{array}{r}
17 \\ +\ 25 \\
\hline
42
\end{array}
$$
양수 끼리의 합은 문제 없이 잘 수행 됩니다.

**-17 + 25**

$$
\begin{array}{r}
1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1110\ 1111\\
+\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 1001\\
\hline\ 
1\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 1000\\
\hline
\text{캐리발생} \\
\hline
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 1000\\
\end{array}
\begin{array}{r}
-17 \\ 
+\ 25 \\
\hline
8 \\
\hline
\text{} \\
\hline
8 \\
\end{array}
$$

-17에 25를 더해주면 MSB 자리를 넘어 올림이 발생합니다. 
캐리가 발생하였지만 올바른 값이 나옵니다.

**-17 -25**

$$
\begin{array}{r}
1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1110\ 1111\\
+\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1110\ 0111\\
\hline\ 
1\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1101\ 0110\\
\hline
\text{캐리발생} \\
\end{array}
\begin{array}{r}
-17 \\ 
\ -25 \\
\hline
-42 \\
\hline
\text{} \\
\end{array}
$$

마찬가지로 캐리가 발생했지만 별다른 조치 없이도 올바른 수가 나온다.

**17 - 25**

$$
\begin{array}{r}
0000\ 0000\ 0000\ 0000\ 0000\ 0000\ 0001\ 0001\\
+\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1110\ 0111\\
\hline\ 
1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1111\ 1000\\
\end{array}
\begin{array}{r}
17 \\ 
\ -25 \\
\hline
-8 \\
\end{array}
$$

캐리가 발생하지 않아 올바른 값이 나온걸 확인할 수 있습니다.
이렇게 2진수에서는 컴퓨터가 연산을 더욱 편리하게 하기 위해 2의 보수를 활용하여 쓰는 것이죠.

2의 보수 방식의 장점을 정리하자면 이렇습니다.

- 장점
	- 1의 보수에 +1을 하면 음수값을 얻을 수 있다.
	 - MSB의 성질이 유지가 된다.
	 - 덧셈만으로 뺄셈을 구현할 수 있어 회로가 단순해진다.
	- 1의 보수의 단점(캐리 발생 문제 및 0이 두 개) 모두 해결이 된다.

# 마무리

컴퓨터가 음수를 표현하고 연산하는 방식은 **인간의 직관**보다 **회로의 효율성**을 우선시하여 발전해왔습니다.

## 3가지 음수 표현 방식 비교

| 방식         | 음수 구현          | 장점               | 단점                              |
| ---------- | -------------- | ---------------- | ------------------------------- |
| **부호 절대값** | MSB를 부호 비트로 사용 | 인간이 이해하기 쉬움      | ±0 중복, 회로 복잡, 연산마다 부호/절대값 따로 처리 |
| **1의 보수**  | 비트 반전          | 음수 구현 간단, MSB 유지 | 캐리 발생 시 +1 처리 필요, ±0 중복         |
| **2의 보수**  | 비트 반전 + 1      | 모든 단점 해결, 회로 단순  | 인간에게 다소 비직관적                    |

컴퓨터는 0과 1만으로 동작하는 환경에서 **뺄셈을 직접 구현하는 것이 매우 복잡**합니다. 
2의 보수를 사용하면:

1. **덧셈만으로 모든 사칙연산 가능** → 회로 설계 단순화
2. **캐리 발생 여부 무관** → 추가 처리 불필요
3. **0의 중복 표현 해소** → 연산 오류 방지
4. **MSB로 부호 판별 유지** → 일관된 처리 가능

현대 모든 컴퓨터의 **CPU 내부 ALU(산술논리장치)**는 2의 보수 방식으로 설계되어 있습니다. 
비록 우리에게는 보수 개념이 낯설지만, 컴퓨터에게는 가장 효율적인 선택입니다.

**기억할 핵심:** 인간에게 쉬운 방법과 기계에게 효율적인 방법은 다르며, 2의 보수는 이 차이를 극명하게 보여주는 사례입니다.
